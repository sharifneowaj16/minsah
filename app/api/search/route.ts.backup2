import { NextRequest, NextResponse } from 'next/server';
import { esClient, PRODUCT_INDEX } from '@/lib/elasticsearch';
import { sanitizeQuery, validateNumericParam, validateSearchParams } from '@/lib/elasticsearch/utils';
import { searchMetrics } from '@/lib/elasticsearch/metrics';

// ✅ Type definitions for search
interface ProductSource {
  id: string;
  name: string;
  slug: string;
  description?: string;
  price: number;
  compareAtPrice?: number;
  category?: string;
  subcategory?: string;
  brand?: string;
  images?: string[];
  inStock: boolean;
  rating?: number;
  tags?: string[];
}

interface SearchHit {
  _id: string;
  _score: number;
  _source: ProductSource;
  highlight?: {
    name?: string[];
    description?: string[];
  };
}

interface AggregationBucket {
  key: string;
  doc_count: number;
}

interface ElasticsearchSearchResponse {
  hits: {
    total: number | { value: number; relation: string };
    hits: SearchHit[];
  };
  aggregations?: {
    categories?: { buckets: AggregationBucket[] };
    brands?: { buckets: AggregationBucket[] };
    price_ranges?: { buckets: AggregationBucket[] };
    avg_price?: { value?: number };
    min_price?: { value?: number };
    max_price?: { value?: number };
  };
}

export async function GET(request: NextRequest) {
  const startTime = Date.now();
  let searchSuccess = false;
  let resultCount = 0;
  let errorMessage: string | undefined;

  try {
    const searchParams = request.nextUrl.searchParams;

    // ✅ VALIDATE REQUEST PARAMETERS
    const validation = validateSearchParams(searchParams);
    if (!validation.valid) {
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid request parameters',
          details: validation.errors,
        },
        { status: 400 }
      );
    }

    // ✅ SANITIZE AND VALIDATE INPUT
    const rawQuery = searchParams.get('q') || '';
    const query = sanitizeQuery(rawQuery);
    const category = searchParams.get('category');
    const subcategory = searchParams.get('subcategory');
    const minPrice = searchParams.get('minPrice');
    const maxPrice = searchParams.get('maxPrice');
    const inStock = searchParams.get('inStock') === 'true';
    const brand = searchParams.get('brand');
    const rating = searchParams.get('rating');
    const tags = searchParams.get('tags')?.split(',').filter(Boolean);
    
    const page = validateNumericParam(searchParams.get('page'), 1, 1, 1000);
    const limit = validateNumericParam(searchParams.get('limit'), 20, 1, 100);
    const sort = searchParams.get('sort') || 'relevance';

    // Build Elasticsearch query
    const must: any[] = [];
    const filter: any[] = [];
    const should: any[] = [];

    // Main search query with multi-field matching
    if (query.trim()) {
      must.push({
        multi_match: {
          query: query,
          fields: [
            'name^5',
            'brand^3',
            'category^2',
            'description^1.5',
            'tags^2',
          ],
          type: 'best_fields',
          fuzziness: 'AUTO',
          prefix_length: 2,
        }
      });

      // Boost exact matches
      should.push({
        match_phrase: {
          name: {
            query: query,
            boost: 3,
          }
        }
      });
    } else {
      must.push({ match_all: {} });
    }

    // Category filter
    if (category) {
      filter.push({ term: { category } });
    }

    // Subcategory filter
    if (subcategory) {
      filter.push({ term: { subcategory } });
    }

    // Brand filter
    if (brand) {
      filter.push({ term: { 'brand.keyword': brand } });
    }

    // Price range filter
    if (minPrice || maxPrice) {
      const priceRange: any = {};
      if (minPrice) priceRange.gte = parseFloat(minPrice);
      if (maxPrice) priceRange.lte = parseFloat(maxPrice);
      filter.push({ range: { price: priceRange } });
    }

    // Stock filter
    if (inStock) {
      filter.push({ term: { inStock: true } });
    }

    // Rating filter
    if (rating) {
      filter.push({ 
        range: { 
          rating: { 
            gte: parseFloat(rating) 
          } 
        } 
      });
    }

    // Tags filter
    if (tags && tags.length > 0) {
      filter.push({
        terms: { tags }
      });
    }

    // Determine sort order
    let sortOrder: any[] = [];
    
    switch (sort) {
      case 'price_asc':
        sortOrder = [{ price: 'asc' }, { _score: 'desc' }];
        break;
      case 'price_desc':
        sortOrder = [{ price: 'desc' }, { _score: 'desc' }];
        break;
      case 'newest':
        sortOrder = [{ createdAt: 'desc' }, { _score: 'desc' }];
        break;
      case 'rating':
        sortOrder = [{ rating: 'desc' }, { _score: 'desc' }];
        break;
      case 'name_asc':
        sortOrder = [{ 'name.keyword': 'asc' }];
        break;
      case 'name_desc':
        sortOrder = [{ 'name.keyword': 'desc' }];
        break;
      case 'relevance':
      default:
        sortOrder = [{ _score: 'desc' }, { createdAt: 'desc' }];
        break;
    }

    // ✅ EXECUTE SEARCH
    const response = await esClient.search({
      index: PRODUCT_INDEX,
      query: {
        bool: {
          must,
          filter,
          should,
          minimum_should_match: should.length > 0 ? 0 : undefined,
        }
      },
      from: (page - 1) * limit,
      size: limit,
      sort: sortOrder,
      highlight: {
        fields: {
          name: {
            pre_tags: ['<mark>'],
            post_tags: ['</mark>'],
          },
          description: {
            pre_tags: ['<mark>'],
            post_tags: ['</mark>'],
            fragment_size: 150,
            number_of_fragments: 3,
          },
        }
      },
      aggs: {
        categories: {
          terms: { field: 'category', size: 20 }
        },
        brands: {
          terms: { field: 'brand.keyword', size: 20 }
        },
        price_ranges: {
          range: {
            field: 'price',
            ranges: [
              { key: 'Under 500', to: 500 },
              { key: '500-1000', from: 500, to: 1000 },
              { key: '1000-2000', from: 1000, to: 2000 },
              { key: '2000-5000', from: 2000, to: 5000 },
              { key: 'Over 5000', from: 5000 },
            ]
          }
        },
        avg_price: { avg: { field: 'price' } },
        min_price: { min: { field: 'price' } },
        max_price: { max: { field: 'price' } },
      }
    });

    // ✅ TYPE-SAFE EXTRACTION
    const searchResponse = response as unknown as ElasticsearchSearchResponse;
    const hits = searchResponse.hits.hits;
    const total = typeof searchResponse.hits.total === 'number'
      ? searchResponse.hits.total
      : (searchResponse.hits.total?.value ?? 0);

    const products = hits.map(hit => ({
      ...hit._source,
      _id: hit._id,
      _score: hit._score,
      highlight: hit.highlight,
    }));

    // ✅ TRACK METRICS
    searchSuccess = true;
    resultCount = total;
    const duration = Date.now() - startTime;

    searchMetrics.add({
      query: query || '[empty]',
      duration,
      resultCount: total,
      filters: [
        category && 'category',
        subcategory && 'subcategory',
        brand && 'brand',
        (minPrice || maxPrice) && 'price',
        inStock && 'inStock',
        rating && 'rating',
        tags && 'tags',
      ].filter(Boolean) as string[],
      timestamp: new Date(),
      success: true,
    });

    // ✅ RETURN RESPONSE WITH METRICS HEADERS
    return NextResponse.json({
      success: true,
      data: {
        products,
        pagination: {
          total,
          page,
          limit,
          totalPages: Math.ceil(total / limit),
          hasNextPage: page * limit < total,
          hasPreviousPage: page > 1,
        },
        aggregations: {
          categories: searchResponse.aggregations?.categories,
          brands: searchResponse.aggregations?.brands,
          priceRanges: searchResponse.aggregations?.price_ranges,
          priceStats: {
            avg: searchResponse.aggregations?.avg_price?.value ?? 0,
            min: searchResponse.aggregations?.min_price?.value ?? 0,
            max: searchResponse.aggregations?.max_price?.value ?? 0,
          }
        },
        query: {
          searchTerm: query,
          filters: {
            category,
            subcategory,
            brand,
            minPrice,
            maxPrice,
            inStock,
            rating,
            tags,
          },
          sort,
        }
      }
    }, {
      headers: {
        'X-Search-Duration': String(duration),
        'X-Result-Count': String(total),
        'Cache-Control': 'public, max-age=60', // Cache for 60 seconds
      }
    });

  } catch (error: any) {
    console.error('❌ Search API error:', error);
    errorMessage = error.message || 'Search failed';

    // ✅ TRACK FAILED SEARCH
    const duration = Date.now() - startTime;
    searchMetrics.add({
      query: searchParams.get('q') || '[empty]',
      duration,
      resultCount: 0,
      filters: [],
      timestamp: new Date(),
      success: false,
      error: errorMessage,
    });
    
    return NextResponse.json(
      { 
        success: false, 
        error: errorMessage,
        details: process.env.NODE_ENV === 'development' ? error.stack : undefined
      },
      { status: 500 }
    );
  }
}
